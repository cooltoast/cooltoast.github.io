<!DOCTYPE html>
<html>
  <head>
    <meta charset=utf-8>
    <title>My first three.js app</title>
    <style>
     body { margin: 0; cursor: move; }
     canvas { width: 100%; height: 100% }
    </style>
  </head>
  <body>
    <script src="js/three.js"></script>
    <script src="js/WebGL.js"></script>
    <script src="js/Water.js"></script>
		<script src="js/Sky.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script>
     var scene = new THREE.Scene();

     var camera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 1, 20000 );
		 camera.position.set( 30, 30, 100 );

     var renderer = new THREE.WebGLRenderer();
     renderer.setPixelRatio( window.devicePixelRatio );
     renderer.setSize( window.innerWidth, window.innerHeight );
     document.body.appendChild( renderer.domElement );

     // light

     light = new THREE.DirectionalLight( 0xffffff, 0.8 );
		 scene.add( light );

     // sky

     var sky = new THREE.Sky();
     sky.scale.setScalar( 10000 );
     scene.add( sky );
     var uniforms = sky.material.uniforms;
     uniforms.turbidity.value = 10;
     uniforms.rayleigh.value = 2;
     uniforms.luminance.value = 1;
     uniforms.mieCoefficient.value = 0.005;
     uniforms.mieDirectionalG.value = 0.8;

     var parameters = {
			 distance: 400,
			 inclination: 0.49,
			 azimuth: 0.12
		 };

		 var cubeCamera = new THREE.CubeCamera( 1, 20000, 256 );
		 cubeCamera.renderTarget.texture.minFilter = THREE.LinearMipMapLinearFilter;
		 function updateSun() {
			 var theta = Math.PI * ( parameters.inclination - 0.5 );
			 var phi = 2 * Math.PI * ( parameters.azimuth - 0.5 );
			 light.position.x = parameters.distance * Math.cos( phi );
			 light.position.y = parameters.distance * Math.sin( phi ) * Math.sin( theta );
			 light.position.z = parameters.distance * Math.sin( phi ) * Math.cos( theta );
			 sky.material.uniforms.sunPosition.value = light.position.copy( light.position );
			 /* water.material.uniforms.sunDirection.value.copy( light.position ).normalize(); */
			 cubeCamera.update( renderer, scene );
		 }
		 updateSun();

     // orbit control

     controls = new THREE.OrbitControls( camera, renderer.domElement );
		 controls.maxPolarAngle = Math.PI * 0.59;
		 controls.target.set( 0, 10, 0 );
		 controls.minDistance = 40.0;
		 controls.maxDistance = 200.0;
		 camera.lookAt( controls.target );


     function render() {
     }

     /* ~~~~~~~~~~~~~~~~ */
     function onResize() {
       camera.aspect = window.innerWidth / window.innerHeight;
       camera.updateProjectionMatrix();

       renderer.setSize( window.innerWidth, window.innerHeight );
     }

     window.addEventListener('resize', onResize);

     function animate() {
	     requestAnimationFrame( animate );
       render();
	     renderer.render( scene, camera );
     }

     if (WEBGL.isWebGLAvailable()) {
       animate();
     } else {
       var warning = WEBGL.getWebGLErrorMessage();
       document.getElementById('container').appendChild(warning);
     }
    </script>
  </body>
</html>
